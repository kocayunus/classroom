<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Giriş</title>
    <link rel="stylesheet" href="https://ghcdn.rawgit.org/alaturka/indexen/main/lib/stylesheet/min.css">
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <style></style>
  </head>
  <body>
    <div class="container">
      <h1 id="giri">Giriş</h1>
      <hr />
      <p><code>ruby
          puts 'Merhaba Dünya'
        </code></p>
      <hr />
      <h2 id="programlama">Programlama</h2>
      <ul>
        <li>
          <p>MİB</p>
        </li>
        <li>
          <p>Bellek</p>
        </li>
        <li>
          <p>Giriş/Çıkış</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Programı belleğe yükle (İşletim Sistemi)</p>
        </li>
        <li>
          <p>Denetimi programa ver (İşletim Sistemi)</p>
        </li>
        <li>
          <p>Bellekte sırayla çalışan buyruklar</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Sınırlı sayıda buyruklar →  Buyruk kümesi (instruction set)</p>
        </li>
        <li>
          <p>Buyruğu veya işlem sonucunu tutan kayıt alanları →  Kaydediciler (registers)</p>
        </li>
        <li>
          <p>Aritmetik ve Mantıksal işlemleri yerine getiren birim →  ALB (ALU)</p>
        </li>
      </ul>
      <hr />
      <p><a href="https://toy.ecylmz.com">Oyuncak Makine</a></p>
      <ul>
        <li>
          <p>Kaydediciler: sadece 1 tane →  Akümülatör (Birikeç)</p>
        </li>
        <li>
          <p>Buyruk kümesi: 14 buyruk</p>
        </li>
      </ul>
      <hr />
      <p>İki sayıyı topla</p>
      <p><code>
          start  load this
          add result
          store result
          load that
          add result
          store result
          load result
          print
          stop
          this   3
          that   5
          result 0
        </code></p>
      <hr />
      <h3 id="kaynak-kod">Kaynak kod</h3>
      <p>Problemin çözümünü ilgili programlama dilinin sözcük ve kurallarıyla anlatan tarif</p>
      <hr />
      <p>MİB’nin anladığı tek dil: makine dili</p>
      <ul>
        <li>Programın çalıştırılması: Kaynak kodla yapılan tarifin MİB’nin dilindeki buyruklara dönüştürülmesi</li>
      </ul>
      <p>Tarifin hayata geçirilmesi (“programın çalıştırılması”)</p>
      <ul>
        <li>
          <p>Önce kaynak kodun tamamını makine diline çevir →  Derleme (compile)</p>
        </li>
        <li>
          <p>Kaynak kodu (tarifi) bir programa girdi olarak vererek tarifteki her cümlenin gereğinin MİB’ne bu program tarafından
            yaptırılmasını sağla →  Yorumlama (interprete)</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Kaynak kod bir tarifin hayata geçmesi için tek başına yeterli değil</p>
        </li>
        <li>
          <p>Sadece makine dilinde yazılan bir tarif doğrudan yeterli (ki onda bile bir
            tür işlemeye ihtiyaç var, bk. örnekte yapılan bellek ilklendirmeleri)</p>
        </li>
        <li>
          <p>Bir derleyiciye veya bir yorumlayıcıya ihtiyaç var</p>
        </li>
      </ul>
      <hr />
      <h3 id="derleme">Derleme</h3>
      <p>(Aşırı basitleştirme içerir)</p>
      <ul>
        <li>
          <p>Kaynak kodu hedef MİB’in buyruklarından oluşan makine diline çevir</p>
        </li>
        <li>
          <p>Bu işlem program çalıştırılmadan önce <strong>bir seferliğine</strong> yapılır</p>
        </li>
        <li>
          <p>Derlenmiş biçimdeki program çalıştırılır</p>
        </li>
        <li>
          <p>Bu modelde program işletim sistemi tarafından doğrudan yüklenerek çalıştırılıyor</p>
        </li>
      </ul>
      <hr />
      <p>```c
        #include <stdio.h></stdio.h></p>
      <p>static int this   = 3;
        static int that   = 5;
        static int result = 0;</p>
      <p>int main()
        {
        result = this + that;</p>
      <pre><code>printf("%d\n", result);

return 0; } ```
</code></pre>
      <hr />
      <h3 id="nesne-kodu">Nesne kodu</h3>
      <p>Object code</p>
      <ul>
        <li>
          <p>Derleme sonucunda elde edilen imajı (ör. çalıştırılabilir kipte bir ikili program dosyası) anlatır</p>
        </li>
        <li>
          <p>Kaynak kodun devamında yer alan bir terim</p>
        </li>
        <li>
          <p>Terimde geçen nesneyi “Nesne Yönelimli”deki (Object Oriented) nesne ile karıştırmayın</p>
        </li>
      </ul>
      <hr />
      <h3 id="yorumlama">Yorumlama</h3>
      <p>(Aşırı basitleştirme içerir; derlemeye göre daha da aşırı)</p>
      <ul>
        <li>
          <p>“Yorumlayıcı” programı belleğe yükle</p>
        </li>
        <li>
          <p>Yorumlayıcı kaynak kodu okur; artık denetim yorumlayıcı programda</p>
        </li>
        <li>
          <p>Yorumlayıcı, kaynak koddaki anlamlı çalıştırma cümlelerini (ör. satırlar) sırayla yorumlar</p>
        </li>
        <li>
          <p>Yorumlama?  Cümleyi anlamlandır ve gereğini MİB’ne (onun anladığı buyruklarla) yaptır</p>
        </li>
        <li>
          <p>Bu modelde program işletim sistemi tarafından yüklenenen bir yorumlayıcının aracılığıyla çalıştırılıyor</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        this = 3
        that = 5</p>
      <p>result = this + that</p>
      <p>puts result
        ```</p>
      <hr />
      <h3 id="alma-zaman">Çalışma zamanı</h3>
      <p>Önemli bir terim: “çalışma zamanı” →  <strong>runtime</strong></p>
      <ul>
        <li>
          <p>Programın çalıştırılması süresince geçen zaman dilimini anlatıyor</p>
        </li>
        <li>
          <p>Derlenen programlarda, derlenmiş program imajının belleğe yüklenip MİB tarafından çalıştırılmaya başlandığı andan,
            sonlandığı ana kadar geçen süre</p>
        </li>
        <li>
          <p>Yorumlanan programlarda, kaynak kodun yorumlayıcı tarafından çalıştırılmaya başlandığı andan, sonlandığı ana kadar
            geçen süre</p>
        </li>
      </ul>
      <hr />
      <h3 id="dinamik-programlama-dilleri">Dinamik programlama dilleri</h3>
      <ul>
        <li>
          <p>Kaynak kod üzerinde çalışma zamanı dışında yapılan başka işlemler de var</p>
        </li>
        <li>
          <p>Bu süreçler de farklı şekilde adlandırılabiliyor, ör. derleme zamanı (compile time)</p>
        </li>
        <li>
          <p>Yorumlanan bir program dilinde kararlar çalışma zamanında dinamik olarak alındığından bu dillere “dinamik program
            dilleri” de deniliyor</p>
        </li>
        <li>
          <p>“Dinamik” teriminin karşı tarafındaki terim: “Statik”</p>
        </li>
        <li>
          <p>Bu nedenle kaynak kod üzerinde çalışma zamanı dışında gerçekleşen süreçler genel olarak “statik” terimiyle
            vasıflandırılıyor</p>
        </li>
        <li>
          <p>Örnek: Statik kod çözümlemesi</p>
        </li>
      </ul>
      <hr />
      <h3 id="yksekalak-seviye-diller">Yüksek/alçak seviye diller</h3>
      <p>Bilinmesinde yarar olan bir terim çifti</p>
      <ul>
        <li>
          <p>Bir programlama dilinde sunulan soyutlamalarla ifade kabiliyeti ne kadar yüksek ise dil de o kadar “yüksek seviye”
            (high-level) bir dil oluyor</p>
        </li>
        <li>
          <p>Karşısındaki terim “alçak seviye” (low-level); soyutlamalar daha az, donanıma daha yakın (ve bir o kadar da denetim
            olanağı)</p>
        </li>
        <li>
          <p>Yüksek/alçak diyerek dilin kalitesine ilişkin bir sıfat oluşturmuyoruz, bu teknik bir tartışma</p>
        </li>
        <li>
          <p>Bunlar göreceli terimler, mutlak anlamda kullanmayın</p>
        </li>
        <li>
          <p>Örnek: Go, Ruby’ye göre alçak-seviye bir dildir, ama C’ye göre yüksek-seviyelidir</p>
        </li>
        <li>
          <p>Yorumlanan (dinamik) diller derlenen dillere göre hemen hemen daima yüksek-seviyeli</p>
        </li>
      </ul>
      <hr />
      <h3 id="derlemeyorumlama">Derleme/Yorumlama</h3>
      <ul>
        <li>
          <p>“Hesaplama” (computing) süreçlerini anlamak için yararlı</p>
        </li>
        <li>
          <p>Günümüzde artık çok anlamlı terimler değil (bk. JIT, bytecode, garbage collector)</p>
        </li>
        <li>
          <p>Pek çok gerçeklemede “yorumlama” sürecinde bir tür derleme yapılıyor (çalışma zamanında)</p>
        </li>
        <li>
          <p>Derleme bazen doğrudan MİB’i hedeflemiyor, sanal bir MİB hedefleniyor (ör. Java sanal makinesi)</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Bu terimler programlama dilinin gerçeklemesiyle ilişkili; programlama diline iliştirilecek mutlak bir özelliği
            anlatmıyor</p>
        </li>
        <li>
          <p>Bir programlama dili, en azından kuramsal olarak, hem derlenen hem yorumlanan biçimde gerçeklenebilir</p>
        </li>
        <li>
          <p>Fakat dil (ortaya çıkışında belirlenmiş) doğası itibarıyla bir tür gerçeklemeyi daha etkin kılar veya bir tür
            gerçeklemeyi teknik olarak çok zorlaştırır</p>
        </li>
        <li>
          <p>“Derlenen/yorumlanan dil” yerine “Kaynak kodun derlenerek/yorumlanarak çalıştırılması öngörülen dil”</p>
        </li>
        <li>
          <p>Ör. Ruby, Python, Javascript yorumlanarak çalıştırılması öngörülen diller</p>
        </li>
        <li>
          <p>Ör. C, Go, Rust derlenerek çalıştırılması öngörülen diller</p>
        </li>
      </ul>
      <hr />
      <h3 id="derlenen-dil">Derlenen dil</h3>
      <p>Avantajlar</p>
      <ul>
        <li>
          <p>Çalışma zamanında yorumlama olmadığından (veya minimize edildiğinden) çok daha hızlı</p>
        </li>
        <li>
          <p>Bellek kullanımı daha az</p>
        </li>
        <li>
          <p>Sorunlar program çalışmadan önce (derleme aşamasında) yakalanabilir</p>
        </li>
        <li>
          <p>Lojistiği daha kolay; hedef platform için derlenmiş programın kurulumu yeterli, ayrıca bir yorumlayıcı kurmanıza gerek
            yok</p>
        </li>
      </ul>
      <p>Dezavantajlar</p>
      <ul>
        <li>
          <p>Yazılması daha maliyetli (derleyiciyi mutlu etmek zorundasınız, tip bildirimleri gibi daha ayrıntılı tarifler
            gerekiyor)</p>
        </li>
        <li>
          <p>Çalışma zamanı üzerinde denetiminiz olmadığından “dinamik” işler çeviremezsiniz</p>
        </li>
        <li>
          <p>(C gibi en azından bir kısım dilde) Çalışma zamanında güvenlik açıkları</p>
        </li>
      </ul>
      <hr />
      <h3 id="yorumlanan-dil">Yorumlanan dil</h3>
      <p>Avantajlar</p>
      <ul>
        <li>
          <p>Geliştirme süresi daha kısa (arada zeki bir yorumlayıcı var, daha kısa lafla çok iş)</p>
        </li>
        <li>
          <p>Çalışma zamanı denetlenebildiğinden “dinamik” işler çevrilebilir</p>
        </li>
        <li>
          <p>Çalışma zamanı denetlenebildiğinden basit güvenlik açıkları yaşanmaz</p>
        </li>
        <li>
          <p>Daha “taşınabilir” (portable); yazdığınız kodun ilgili platformda çalışması için yorumlayıcının o platformda kurulu
            olması yeterli (fakat bk. lojistik)</p>
        </li>
      </ul>
      <p>Dezavantajlar</p>
      <ul>
        <li>
          <p>Daha yavaş</p>
        </li>
        <li>
          <p>Daha fazla bellek tüketimi</p>
        </li>
        <li>
          <p>Çalışma zamanında yaşanan sürpriz hatalar (derlenebilseydi çalıştırmadan önce yakalanabilirdi)</p>
        </li>
        <li>
          <p>Artan lojistik yük (yorumlayıcı kurulumu gerekiyor)</p>
        </li>
      </ul>
      <hr />
      <p>Yorumlanması öngörülen bir dilde programın çalışma süresi ve bellek tüketimini artırmak pahasına, programın geliştirme
        süresini azaltıyoruz</p>
      <ul>
        <li>
          <p>Birim zamanda daha fazla iş</p>
        </li>
        <li>
          <p>Daha çabuk hayata geçen fikirler</p>
        </li>
      </ul>
      <hr />
      <p>(Ama ile başlayacak eleştirilere açık bir yargı)</p>
      <p><strong>Dinamik (yorumlanan) bir dilde geliştirici konforu hedeflenir</strong></p>
      <ul>
        <li>Sistem kaynaklarını (MİB, bellek vs) daha konforsuz bir durumda tutmak pahasına</li>
      </ul>
      <hr />
      <h3 id="gnmz-trendleri">Günümüz trendleri</h3>
      <ul>
        <li>
          <p>Ayrım yine korunmakla birlikte her iki türün en iyi özellikleri dillere eklenebiliyor</p>
        </li>
        <li>
          <p>Yorumlanan dillerde tip bildirimleri</p>
        </li>
        <li>
          <p>Derlenen dillerde çalışma zamanını denetleyen eklemeler (ör. çöp toplayıcı)</p>
        </li>
        <li>
          <p>Teknik olarak geçerli, fakat pratikte hatalı kod parçalarını geliştirme aşamasında yakalayan zengin statik
            çözümlemeler (“lint”leme)</p>
        </li>
      </ul>
      <hr />
      <h1 id="ruby">Ruby</h1>
      <hr />
      <h3 id="deiken">Değişken</h3>
      <p>İsimlendirilmiş bellek hücresi</p>
      <ul>
        <li>
          <p>Bellek hücresinde (bir tür) veri var</p>
        </li>
        <li>
          <p>Veriye anlamlı bir isimle erişiyoruz</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        kur = 8.96
        dolar = 100.0</p>
      <p>tl = kur * dolar
        ```</p>
      <hr />
      <p>```ruby
        oran = 18.0 / 100
        fiyat = 100.0</p>
      <p>kdv = fiyat * oran
        ```</p>
      <hr />
      <h3 id="simlendirme">İsimlendirme</h3>
      <p>Söz dizimi (sentaks) kuralları</p>
      <ul>
        <li>
          <p>İlk karakter İngilizce alfabedeki küçük/büyük harflerden biri veya alt tire (<code>_</code>) olmalı</p>
        </li>
        <li>
          <p>Varsa devam eden karakterlerde ilkine ilave olarak rakamlar kullanılabilir (ama ilk karakter rakam olamaz)</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Sadece değişkenler değil, metot adları, sabitler, sınıf/modül adları da (Ruby’de bunlar da birer sabit isim)
            isimlendirmenin kapsamında</p>
        </li>
        <li>
          <p>Bu isimlere genel olarak “tanımlayıcı” (identifier) deniliyor</p>
        </li>
        <li>
          <p>İsimlendirme söz dizimi kuralları →  Tanımlayıcı söz dizimi kuralları</p>
        </li>
      </ul>
      <hr />
      <p><strong>Uygun isimlendirme kod okunurluğunu çok artırır</strong></p>
      <ul>
        <li>
          <p>Her program bir öykü veya (uzunluğuna göre) bir roman</p>
        </li>
        <li>
          <p>İsimler bu öykünün kahramanları</p>
        </li>
        <li>
          <p>Anlamlı isimler öykünün okunmasını kolaylaştırıyor</p>
        </li>
      </ul>
      <hr />
      <p>Türkçe karakterler?</p>
      <table>
        <thead>
          <tr>
            <th> </th>
            <th> </th>
            <th> </th>
            <th> </th>
            <th> </th>
            <th> </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>ç</code></td>
            <td><code>ğ</code></td>
            <td><code>ı</code></td>
            <td><code>ö</code></td>
            <td><code>ş</code></td>
            <td><code>ü</code></td>
          </tr>
          <tr>
            <td><code>Ç</code></td>
            <td><code>Ğ</code></td>
            <td><code>İ</code></td>
            <td><code>Ö</code></td>
            <td><code>Ş</code></td>
            <td><code>Ü</code></td>
          </tr>
        </tbody>
      </table>
      <ul>
        <li><code>ı</code> ve <code>İ</code>‘ye dikkat!  (<code>i</code> ve <code>I</code> Türkçe’ye özgü değil)</li>
        <li>Değişken adlarında Türkçe karakter çoğu durumda kullanabiliriz, ama kullanmamalıyız</li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Programlama evrensel bir etkinlik</p>
        </li>
        <li>
          <p>Programlama dillerinin anahtar kelimeleri de İngilizce</p>
        </li>
        <li>
          <p>İsimlendirmeleri enternasyonal yapmakta yarar var; özellikle her dilden geliştiricinin katkı sunabileceği açık kaynak
            projelerde</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        exchange_rate = 8.96
        usd = 100.0</p>
      <p>tl = exchange_rate * usd</p>
      <p>tax_rate = 18.0 / 100
        price = 100.0</p>
      <p>tax = price * tax_rate
        ```</p>
      <hr />
      <h3 id="fadeler">İfadeler</h3>
      <ul>
        <li>
          <p>Değerlendirmeye (evaluation) konu ögeler</p>
        </li>
        <li>
          <p>Değerlendirme?  Hesaplama, değer verme</p>
        </li>
        <li>
          <p>Örnek: <code>exchange_rate * usd</code></p>
        </li>
        <li>
          <p>Bu bir aritmetik ifade</p>
        </li>
        <li>
          <p>Örnek: <code>usd = exchange_rate * usd</code></p>
        </li>
        <li>
          <p>Bu (aritmetik ifade içeren) bir “atama” (assignment) ifadesi</p>
        </li>
      </ul>
      <hr />
      <p><strong>Her ifade bir değer döner</strong> (değerlendirme sonrası)</p>
      <ul>
        <li>
          <p>Ruby’de ilkel değerlerin bizzat kendisi de ifade</p>
        </li>
        <li>
          <p>Örnek: <code>100.0</code></p>
        </li>
        <li>
          <p><code>usd = 100.0</code> atama ifadesinde önce sağ taraf değerlendirilir, dönen değer (<code>100.0</code>) sol taraftaki değişkene atanır</p>
        </li>
      </ul>
      <hr />
      <p><strong>Ruby’de her şey bir ifadedir</strong></p>
      <ul>
        <li>
          <p>IRB’de girilen bir satır <code>enter</code> tuşu ile yorumlayıcıya gönderilir</p>
        </li>
        <li>
          <p>IRB, satırı bir bütün halde ifade olarak yorumlar</p>
        </li>
        <li>
          <p>İfadenin döndüğü değer <code>#=&gt;</code> ile belirtilir</p>
        </li>
      </ul>
      <hr />
      <h3 id="aritmetik-operatrler">Aritmetik operatörler</h3>
      <ul>
        <li>
          <p>Operatör →  İşleç</p>
        </li>
        <li>
          <p>Sayısal türde değerleri operatörlerle düzenleyerek dönüş değeri yine sayısal türde olan aritmetik ifadeler kurabiliyoruz</p>
        </li>
        <li>
          <p>Sayısal tür?  Tam sayı, Gerçel sayı, Rasyonel sayı</p>
        </li>
        <li>
          <p>Aritmetik operatörler beklediğiniz gibi: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></p>
        </li>
        <li>
          <p>Ayrıca iki operatör: <code>%</code> modülüs ve <code>**</code> üs alma operatörleri</p>
        </li>
      </ul>
      <hr />
      <h3 id="saysal-tr">Sayısal tür</h3>
      <ul>
        <li>
          <p>Tam sayı ve gerçel sayılar</p>
        </li>
        <li>
          <p>Gerçel sayılarla kurulan ifadelere dikkat!  <code>18.0 / 100</code> yerine <code>18 / 100</code> yazılırsa?</p>
        </li>
      </ul>
      <hr />
      <p>Ruby’de Rasyonel sayıların gösterimi için özel bir söz dizimi kullanılıyor</p>
      <p><code>ruby
          tax_rate = 18/100r
        </code></p>
      <ul>
        <li>
          <p>Daha okunur</p>
        </li>
        <li>
          <p>Bunu nasıl kullanacağız?  Göründüğü gibi, ör. <code>18/100r * 100.0</code></p>
        </li>
      </ul>
      <hr />
      <p>Tür dönüşümleri yapılabilir</p>
      <ul>
        <li>
          <p>Değer nesneleri üzerinde çalıştırılacak iki metot: <code>to_i</code> ve <code>to_f</code></p>
        </li>
        <li>
          <p>Bir değeri tamsayıya çevirmek için <code>to_i</code>, ör. <code>18.9.to_i #=&gt; 18</code></p>
        </li>
        <li>
          <p>Bir değeri gerçel sayıya çevirmek için <code>to_f</code>, ör. <code>18/100r.to_f #=&gt; 0.18</code></p>
        </li>
        <li>
          <p>Değer bu dönüşümü desteklemeli</p>
        </li>
      </ul>
      <hr />
      <h3 id="fonksiyonlar">Fonksiyonlar</h3>
      <p><code>ruby
          value = Math.sin(0.5236) # 0.5236 ~ Pi/6 ~ 30 derece
        </code></p>
      <ul>
        <li>
          <p>Matematikte aşina olduğumuz bir trigonometrik fonksiyon: <code>sin</code></p>
        </li>
        <li>
          <p><code>&lt;fonksiyon&gt;(girdi listesi) →  çıktı</code></p>
        </li>
        <li>
          <p>Fonksiyonlara giriş değerlerini argümanlar yoluyla iletiyoruz, örnekte <code>30</code> derece <code>sin</code> fonksiyonuna iletiliyor</p>
        </li>
        <li>
          <p>Fonksiyon (isminin yansıttığı) hesaplamayı yapıp bir değer dönüyor, örnekte <code>0.5</code></p>
        </li>
        <li>
          <p>Ruby’de bir fonksiyona geçirilen argümanlar etrafında parantez kullanmanız her zaman gerekmiyor</p>
        </li>
      </ul>
      <hr />
      <p>Matematiksel fonksiyonlardan bir parça farklı olarak programlamada yazacağınız fonksiyonlar:</p>
      <ul>
        <li>
          <p>Hiç argüman istemeyebilir</p>
        </li>
        <li>
          <p>Birden fazla argüman isteyebilir</p>
        </li>
        <li>
          <p>Bir değer dönmeyebilir</p>
        </li>
        <li>
          <p>Dönecekse sadece tek bir değer döner (bazı dillerde, ör. Go, birden fazla değer dönülebilir)</p>
        </li>
      </ul>
      <hr />
      <h3 id="fonksiyon-veya-metot">Fonksiyon veya Metot</h3>
      <p>Ruby gibi Nesne Yönelimli dillerde fonksiyon yerine metot adlandırması tercih ediliyor</p>
      <ul>
        <li>
          <p>Bu bir isimlendirme inceliği (bazı nedenleri var, gelecekte daha ayrıntılı değineceğiz)</p>
        </li>
        <li>
          <p>Bundan sonra fonksiyon değil metot diyeceğiz</p>
        </li>
      </ul>
      <hr />
      <p>Metotlarla ilk karşılaşmamız:</p>
      <p><code>ruby
          puts 'Merhaba Dünya'
        </code></p>
      <ul>
        <li>
          <p><code>puts</code> bir metot (yani fonksiyon)</p>
        </li>
        <li>
          <p>Metotlara genel olarak bir nesne üzerinde <code>.</code> operatörüyle erişiyoruz</p>
        </li>
        <li>
          <p>Fakat bu örnekte metot bir nesne üzerinden değil doğrudan çağrılıyor</p>
        </li>
        <li>
          <p>Bu konuya gelecekte değineceğiz</p>
        </li>
      </ul>
      <hr />
      <h3 id="nesne-nokta-metot-notasyonu">Nesne Nokta Metot notasyonu</h3>
      <p>Notasyona dikkat edin!  <code>18.to_f #=&gt; 18.0</code></p>
      <ul>
        <li>
          <p>Noktanın solunda bir değer: <code>18</code>, sağında ise bir metot: <code>to_f</code> bulunuyor</p>
        </li>
        <li>
          <p>Noktanın solundaki “değer” aslında bir “nesne” (object)</p>
        </li>
        <li>
          <p>Nesnelere <code>.</code> operatörü yoluyla bir mesaj iletiyoruz</p>
        </li>
        <li>
          <p>Mesaj →  Metot</p>
        </li>
        <li>
          <p>Nesne mesajın gereğini yerine getiriyor (ilgili metot çağrılıyor)</p>
        </li>
      </ul>
      <hr />
      <p><strong>Ruby’de hemen her şey bir nesne</strong></p>
      <ul>
        <li>Nesneleri <code>.&lt;metot&gt;</code> söz dizimiyle uyarıyoruz</li>
      </ul>
      <hr />
      <h3 id="lkel-veri-trleri">İlkel veri türleri</h3>
      <ul>
        <li>
          <p>Sayısal türler ilkel (primitive) veri türlerinin en yaygın örneği</p>
        </li>
        <li>
          <p>Pek çok programlama dilinde bir diğer önemli veri türü: “dizgi” (string)</p>
        </li>
      </ul>
      <hr />
      <h3 id="dizgi">Dizgi</h3>
      <p>```ruby
        message = ‘Merhaba Dünya’</p>
      <p>puts message
        ```</p>
      <ul>
        <li>
          <p>Örnekteki <code>'Merhaba Dünya'</code> değeri bir dizgi (string)</p>
        </li>
        <li>
          <p>Çift tırnak veya tek tırnak kullanabiliriz</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        who = ‘Dünya’
        message = “Merhaba #{who}”</p>
      <p>puts message
        ```</p>
      <ul>
        <li>
          <p>Çift tırnakta Ruby dizgi değerini özel olarak yorumlar →  “Dizgi Enterpolasyonu” (String Interpolation)</p>
        </li>
        <li>
          <p><code>#{}</code> arasına istediğiniz karmaşıklıkta bir Ruby kodu yazabilirsiniz</p>
        </li>
        <li>
          <p>Yorumlayıcı <code>#{}</code> arasındaki kodu bir ifade olarak değerlendirir ve dönüş değerini yerine koyar</p>
        </li>
        <li>
          <p>Bu örnekte tek tırnak kullanılsaydı <code>message</code> dizgisi olduğu gibi (literal) yorumlanacaktı</p>
        </li>
      </ul>
      <hr />
      <p>Dizgiler programlama dillerinde çok temel bir veri türü</p>
      <ul>
        <li>Her bir tespih tanesi bir “karakter” (character, char) olan bir tespih gibi</li>
      </ul>
      <hr />
      <h3 id="karakter">Karakter</h3>
      <ul>
        <li>
          <p>Dizgilerin yapıtaşları; kabaca harfler, rakamlar ve noktalama işaretleri</p>
        </li>
        <li>
          <p>Bunlara ilave kontrol karakterleri var: boşluk, satır sonu, sekme gibi</p>
        </li>
        <li>
          <p>Karakterler belirli sayıda bitlik bir bilgiyle kodlanıyor</p>
        </li>
        <li>
          <p>En bilineni 7 bitlik ASCII: American Standard Code for Information Interchange</p>
        </li>
        <li>
          <p>Türkçe gibi dile özgü karakterler ASCII tabloda yok</p>
        </li>
        <li>
          <p>Bunun yerine günümüzde UTF-8 gibi daha evrensel kodlama standartları kullanılıyor</p>
        </li>
        <li>
          <p>Yine de ASCII tabloya hakim olmalısınız (örneğin UTF-8 ASCII’nin bir tür üst sürümü)</p>
        </li>
      </ul>
      <hr />
      <h3 id="ascii-tablo">ASCII Tablo</h3>
      <p><code>
          Dec  Char                           Dec  Char     Dec  Char     Dec  Char
          ---------                           ---------     ---------     ----------
          0  NUL (null)                      32  SPACE     64  @         96  `
          1  SOH (start of heading)          33  !         65  A         97  a
          2  STX (start of text)             34  "         66  B         98  b
          3  ETX (end of text)               35  #         67  C         99  c
          4  EOT (end of transmission)       36  $         68  D        100  d
          5  ENQ (enquiry)                   37  %         69  E        101  e
          6  ACK (acknowledge)               38  &amp;         70  F        102  f
          7  BEL (bell)                      39  '         71  G        103  g
          8  BS  (backspace)                 40  (         72  H        104  h
          9  TAB (horizontal tab)            41  )         73  I        105  i
          10  LF  (NL line feed, new line)    42  *         74  J        106  j
          11  VT  (vertical tab)              43  +         75  K        107  k
          12  FF  (NP form feed, new page)    44  ,         76  L        108  l
          13  CR  (carriage return)           45  -         77  M        109  m
          14  SO  (shift out)                 46  .         78  N        110  n
          15  SI  (shift in)                  47  /         79  O        111  o
          16  DLE (data link escape)          48  0         80  P        112  p
          17  DC1 (device control 1)          49  1         81  Q        113  q
          18  DC2 (device control 2)          50  2         82  R        114  r
          19  DC3 (device control 3)          51  3         83  S        115  s
          20  DC4 (device control 4)          52  4         84  T        116  t
          21  NAK (negative acknowledge)      53  5         85  U        117  u
          22  SYN (synchronous idle)          54  6         86  V        118  v
          23  ETB (end of trans. block)       55  7         87  W        119  w
          24  CAN (cancel)                    56  8         88  X        120  x
          25  EM  (end of medium)             57  9         89  Y        121  y
          26  SUB (substitute)                58  :         90  Z        122  z
          27  ESC (escape)                    59  ;         91  [        123  {
          28  FS  (file separator)            60  &lt;         92  \        124  |
          29  GS  (group separator)           61  =         93  ]        125  }
          30  RS  (record separator)          62  &gt;         94  ^        126  ~
          31  US  (unit separator)            63  ?         95  _        127  DEL
        </code></p>
      <hr />
      <p><strong>Ruby’de karakterler özel bir veri türü değildir</strong></p>
      <ul>
        <li>Ama örneğin C gibi bazı programlama dillerinde çoğunlukla <code>char</code> adında özel bir veri türüdür
          (Ruby’den farklı olarak C programlama dilinde dizgi veri türü yoktur)</li>
      </ul>
      <hr />
      <p>Ruby’de bir karakterin ASCII tablodaki onluk tabanda kodunu öğren: <code>.ord</code></p>
      <p><code>ruby
          'a'.ord
          ' '.ord
          "\n".ord
          "\t".ord
        </code></p>
      <p>Onlu tabanda verilen bir kodu karakteri içeren dizgiye çevir: <code>.chr</code></p>
      <p><code>ruby
          97.chr
        </code></p>
      <hr />
      <p>Özel karakterler</p>
      <ul>
        <li><code>"\n"</code> →  Satır sonu</li>
        <li><code>"\t"</code> →  Sekme</li>
        <li>Bunlar en yaygınları, bunların dışında ters bölü karakteriyle nitelendirilen başka kodlar da var</li>
      </ul>
      <hr />
      <p>Beyaz boşluk (whitespace)</p>
      <ul>
        <li>
          <p>Kabaca; boşluk, satır sonu ve sekme karakterlerine deniliyor (ama başkaları da var)</p>
        </li>
        <li>
          <p>Dizgi içinde kullanılmadığında, kaynak kod ayrıştırılırken bu karakterler göz ardı edilir veya kodun söz dizimsel
            olarak farklı parçalarını birbirinden ayırır</p>
        </li>
      </ul>
      <hr />
      <h3 id="temel-baz-dizgi-metotlar">Temel bazı dizgi metotları</h3>
      <p>```ruby
        string = gets</p>
      <p>puts string.size # string.length
        puts string.empty?
        puts string.chomp
        puts string.chop
        puts string.upcase
        puts string.downcase
        puts string.capitalize
        puts string.tr ‘<em>’, ‘ ‘
          puts string.delete ‘</em>’
        puts string.strip
        puts string.start_with? ‘2021’
        puts string.end_with? ‘2021’
        puts string.delete_prefix ‘2021’
        puts string.delete_suffix ‘.rb’
        ```</p>
      <hr />
      <p>String birleştirme (“concatenate”)</p>
      <p>```ruby
        string = ‘’</p>
      <p>string « ‘Cezmi’
        string « ’ ‘
        string « ‘Seha’</p>
      <p>puts string
        ```</p>
      <hr />
      <p><code># frozen_string_literal: true</code>?</p>
      <ul>
        <li>
          <p>Bu bir pragma</p>
        </li>
        <li>
          <p>Kaynak koddaki tüm dizgi literallerini öntanımlı olarak “değiştirilemez” yapıyor</p>
        </li>
        <li>
          <p>Bu sayede aynı dizgi literali için bellek ayırmak gerekmiyor</p>
        </li>
        <li>
          <p>Yorumlayıcıya verdiğiniz açık sözün denetlenmesi sağlanıyor (hata yakalama)</p>
        </li>
      </ul>
      <p><code>ruby
          city = 'Samsun'.freeze
          city &lt;&lt; '55' # hata
        </code></p>
      <p>yerine</p>
      <p>```ruby
        # frozen_string_literal: true</p>
      <p>city = ‘Samsun’
        city « ‘55’ # hata
        ```</p>
      <hr />
      <p><code># frozen_string_literal: true</code> yapılırsa birleştirmeler nasıl?</p>
      <ul>
        <li>IRB’de sorunu görmeyebilirsiniz (görmek için <code>RUBYOPT="--enable-frozen-string-literal" irb</code>)</li>
      </ul>
      <p><code>ruby
          string = String.new '' # string = '' yerine
        </code></p>
      <p>(Dikkat! <code>String.new</code>‘i argümansız çalıştırırsanız karakter kodlaması ASCII oluyor)</p>
      <hr />
      <h3 id="ak-denetimi">Akış denetimi</h3>
      <ul>
        <li>
          <p>Kod akışını farklı kod yollarına bölen koşul deyimleri</p>
        </li>
        <li>
          <p>Kod bloklarının etkinleştirilmesi belirli koşulların sağlanmasına bağlanıyor</p>
        </li>
      </ul>
      <hr />
      <h3 id="rnek-katsaylar-verilen-kuadratik-kinci-derece-bir-denklemde-zm-var-m">Örnek: Katsayıları verilen kuadratik (İkinci derece) bir denklemde çözüm var mı?</h3>
      <p>Diskriminant pozitif olmalı (alan bilgisi)</p>
      <p>```ruby
        a, b, c = 1.0, 0.0, 1.0</p>
      <p>delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        puts ‘Çözüm var’
        end
        ```</p>
      <hr />
      <ul>
        <li>
          <p><code>if</code>, <code>end</code> birer anahtar kelime</p>
        </li>
        <li>
          <p>Koşul ifadesi: <code>delta &gt;= 0.0</code> aritmetik karşılaştırma içeren bir mantık (lojik) ifade</p>
        </li>
        <li>
          <p>Aritmetik karşılaştırma operatörü <code>&gt;=</code> “büyük veya eşit”</p>
        </li>
        <li>
          <p>Gerçel sayı karşılaştırmalarını böyle yapmayın, sorunu görebiliyor musunuz?</p>
        </li>
        <li>
          <p>İlk satırda paralel atama yapılıyor (kötüye kullanmayın)</p>
        </li>
      </ul>
      <hr />
      <p>Gövdesi tek satır olan <code>if</code> deyimlerini tek satırda yazabiliyoruz</p>
      <p>```ruby
        a, b, c = 1.0, 0.0, 1.0</p>
      <p>delta = b ** 2 - 4 * a * c</p>
      <p>puts ‘Çözüm var’ if delta &gt;= 0.0
        ```</p>
      <hr />
      <p>```ruby
        a, b, c = 1.0, 0.0, 1.0</p>
      <p>delta = b ** 2 - 4 * a * c</p>
      <p>puts ‘Çözüm var’ unless delta &lt; 0.0
        ```</p>
      <hr />
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>unless</code></p>
        </li>
        <li>
          <p>Negatif lojik için kullanılıyor</p>
        </li>
        <li>
          <p>Özellikle <code>!</code> değillemeleri içeren basit ifadelerde yararlı</p>
        </li>
        <li>
          <p>Okunurluğu (yerine göre) bir parça arttırıyor</p>
        </li>
      </ul>
      <hr />
      <p>Örnek: Katsayıları verilen kuadratik denklemin gerçel kökleri neler?</p>
      <p>```ruby
        a, b, c = 1.0, 0.0, 1.0</p>
      <p>delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <p>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a</p>
      <p>puts “Kökler: (#{p}, #{q})”
        else
        puts ‘Çözüm yok’
        end
        ```</p>
      <ul>
        <li>Yeni anahtar kelime: <code>else</code></li>
      </ul>
      <hr />
      <p>Örnek: Verilen 3 sayı geçerli bir üçgenin kenar uzunlukları mı?</p>
      <p>Üçgen kuralı (alan bilgisi): Sayılardan herhangi ikisinin toplamı üçüncüden <strong>daima</strong> büyüktür</p>
      <p>```ruby
        a, b, c = 3, 4, 5</p>
      <p>if a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        puts “Geçerli üçgen”
        else
        puts “Geçerli üçgen değil”
        end
        ```</p>
      <ul>
        <li>
          <p>Koşulda mantıksal (lojik) bir ifade, önermeler <code>&amp;&amp;</code> “ve” mantık operatörüyle bağlanmış</p>
        </li>
        <li>
          <p>Önermelerin her biri aritmetik karşılaştırma, <code>&gt;</code> “büyüktür”</p>
        </li>
      </ul>
      <hr />
      <p>Örnek: Kullanıcıdan bir tam sayı iste</p>
      <p>```ruby
        print ‘Lütfen bir sayı girin: ‘
        string = gets.chomp</p>
      <p>if string == ‘’
        puts ‘Hiç bir şey girmediniz.’
        elsif (number = Integer(string, exception: false))
        puts “Girdiğiniz sayı #{number}”
        else
        puts “Geçersiz sayı girdiniz: #{string}”
        end
        ```</p>
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>elsif</code>, çoklu koşul deyimleri</p>
        </li>
        <li>
          <p><code>Integer(string, exception: false)</code> hatalı dönüşümde <code>nil</code> değeri dönüyor</p>
        </li>
        <li>
          <p>Koşul ifadesi içinde atama yapabilirsiniz (kötüye kullanmayın), yeter ki parantezlerle niyetinizi açık hale getirin</p>
        </li>
        <li>
          <p>Boş dizgi denetimi daha deyimsel nasıl yapılabilir?</p>
        </li>
        <li>
          <p>Kullanıcı bir veya daha fazla sayıda beyaz boşluk girmişse?</p>
        </li>
      </ul>
      <hr />
      <h3 id="nil"><code>nil</code></h3>
      <p>Düpedüz yokluğu veya geçerli bir değerin yokluğunu anlatan “sözde değer”</p>
      <ul>
        <li>
          <p>Mantıksal bağlamda <code>false</code> ile benzer sonuçlar üretiyor</p>
        </li>
        <li>
          <p>Yani bu bir “falsy” değer</p>
        </li>
        <li>
          <p>Diğer dillerde de kısmen benzer değerler var; ör. C, C#, Java’da <code>null</code></p>
        </li>
      </ul>
      <hr />
      <h3 id="dorulukyanllk">Doğruluk/Yanlışlık</h3>
      <p>Basit iki kural</p>
      <ol>
        <li>
          <p><strong>Ruby’de değeri <code>false</code> ve <code>nil</code> olan her ifade yanlıştır</strong></p>
        </li>
        <li>
          <p><strong>Yanlış olmayan her şey doğrudur</strong></p>
        </li>
      </ol>
      <hr />
      <p>```ruby
        number = Integer(‘geçersiz’, exception: false) #=&gt; nil</p>
      <p>if number
        puts ‘Doğru’
        else
        puts ‘Yanlış’
        end
        ```</p>
      <hr />
      <p>Bazen <code>nil</code> değerini açıkça denetlemeniz gerekebilir</p>
      <p>```ruby
        number = Integer(‘geçersiz’, exception: false) #=&gt; nil</p>
      <p>if number.nil?
        puts ‘Evet: nil’
        end
        ```</p>
      <hr />
      <p>Yeri gelmişken…  “Ruby’de her şey bir ifade” demiştik, örneği inceleyelim</p>
      <p><code>ruby
          flag =
          if x == 0
          false
          else
          true
          end
        </code></p>
      <ul>
        <li>Herşeyin ifade olmadığı pek çok dilde böyle bir kod yazamazsınız (<code>if</code> pek çok dilde bir ifade değil bir deyimdir)</li>
      </ul>
      <hr />
      <p><code>ruby
          flag =
          if x == 0
          false
          else
          true
          end
        </code></p>
      <p>Bu kodu basitçe şöyle yazabilirdiniz</p>
      <p><code>ruby
          flag = x == 0
        </code></p>
      <hr />
      <h3 id="metot">Metot</h3>
      <p>İsmiyle çağrılarak çalıştırılabilir (bir veya çoğunlukla birden fazla satırlık) kod parçası</p>
      <ul>
        <li>
          <p>Farklı girdilerle tekrar tekrar yapılan hesaplamalar için her seferinde aynı kodu yazmanız gerekmiyor</p>
        </li>
        <li>
          <p>Hesaplama girdileri çağırma zamanında verilen parametrelerle değiştirilebilir</p>
        </li>
      </ul>
      <hr />
      <p>Örnek: Katsayıları verilen kuadratik (İkinci derece) bir denklemin gerçel köklerini bul</p>
      <p>```ruby
        def calculate_roots(a, b, c)
        delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <pre><code>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a
  
puts "Kökler: (#{p}, #{q})"   else
puts 'Çözüm yok'   end end
</code></pre>
      <p>a, b, c = 1.0, 0.0, 1.0</p>
      <p>calculate_roots(a, b, c)
        ```</p>
      <hr />
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>def</code></p>
        </li>
        <li>
          <p><code>a</code>, <code>b</code> ve <code>c</code> metot argümanları</p>
        </li>
        <li>
          <p>Çağırma zamanında metoda bu argümanlarla değerleri geçiriyoruz</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Metot argümanlarıyla çağırma zamanında kullanılan değişkenlerin aynı isimde olması gerekmiyor</p>
          <p>```ruby
            a2, a1, a0 = 1.0, 0.0, 1.0</p>
          <p>calculate_roots(a2, a1, a0)
            ```</p>
        </li>
        <li>
          <p>Değerleri hiç bir değişken kullanmadan da geçirebiliriz</p>
          <p><code>ruby
              calculate_roots(1.0, 0.0, 1.0)
            </code></p>
        </li>
      </ul>
      <hr />
      <p>Örnek: Verilen 3 sayı geçerli bir üçgenin kenar uzunlukları mı?</p>
      <p>```ruby
        def validate_triangle(a, b, c)
        if a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        puts “Geçerli üçgen”
        else
        puts “Geçerli üçgen değil”
        end
        end</p>
      <p>validate_triangle(3, 4, 5)
        ```</p>
      <hr />
      <p>Metotlar çoğunlukla bir hesap yaptıktan sonra bize bir sonuç döner</p>
      <ul>
        <li>
          <p>Her iki örnekte de bir sonuç dönmedik</p>
        </li>
        <li>
          <p>Son örnekte aşama aşama giderek gösterelim</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        def validate_triangle(a, b, c)
        if a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        return true
        else
        return false
        end
        end</p>
      <p>if validate_triangle(3, 4, 5)
        puts “Geçerli üçgen”
        else
        puts “Geçerli üçgen değil”
        end
        ```</p>
      <hr />
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>return</code></p>
        </li>
        <li>
          <p>Kullanıldığı noktada metotu sonlandırarak verilen değeri çağıran tarafa dönüyor</p>
        </li>
      </ul>
      <hr />
      <p>Her metot tek bir iş yapmalı</p>
      <ul>
        <li>İlk örnekte bu kural nasıl ihlal edilmiş?</li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Ruby zaten <code>true</code>/<code>false</code> hesabını yapıyor, biz ayrıca neden hesap ediyoruz?</p>
        </li>
        <li>
          <p>Ruby’de metottan çıkarken etkin olan son satır aynı zamanda dönüş değeridir</p>
        </li>
        <li>
          <p>Çoğu zaman <code>return</code> ile açık dönüş yapmamız gerekmez</p>
        </li>
        <li>
          <p>Ruby’de <code>return</code> deyimini “erken çıkış”lar için kullanın</p>
        </li>
      </ul>
      <hr />
      <p>```ruby
        def validate_triangle(a, b, c)
        a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        end</p>
      <p>if validate_triangle(3, 4, 5)
        puts “Geçerli üçgen”
        else
        puts “Geçerli üçgen değil”
        end
        ```</p>
      <hr />
      <p>Örnek: Kullanıcıdan bir tam sayı iste</p>
      <p>```ruby
        def getnum
        print ‘Lütfen bir sayı girin: ‘
        string = gets.chomp</p>
      <p>if string.empty?
        puts ‘Hiç bir şey girmediniz.’
        elsif (number = Integer(string, exception: false))
        puts “Girdiğiniz sayı #{number}”
        else
        puts “Geçersiz sayı girdiniz: #{string}”
        end</p>
      <p>number
        end
        ```</p>
      <hr />
      <p>İsimlendirmeler çok önemli</p>
      <ul>
        <li>
          <p>Ruby’de metot adlarının sonunda <code>?</code> ve <code>!</code> karakterlerini kullanabilirsiniz</p>
        </li>
        <li>
          <p><code>true</code> veya <code>false</code> değer dönen metotlara “predicate method” diyoruz</p>
        </li>
        <li>
          <p><code>?</code> sonlandırma karakteri bir metotun “predicate” olduğunu nitelendirmekte kullanılan bir konvansiyon</p>
        </li>
        <li>
          <p>Bu sadece bir konvansiyon, metot adının sonunda <code>?</code> karakteri olunca sihirli bir işlem gerçekleşmiyor</p>
        </li>
        <li>
          <p>İsimlendirmeleri çok daha anlamlı yapıyor</p>
        </li>
      </ul>
      <hr />
      <p>Örnek: Katsayıları verilen kuadratik (İkinci derece) bir denklemde çözüm var mı?</p>
      <p>Diskriminant pozitif olmalı (alan bilgisi)</p>
      <p>```ruby
        def has_solution?(a, b, c)
        (b ** 2 - 4 * a * c) &gt;= 0.0
        end</p>
      <p>if has_solution?(1.0, 0.0, 1.0)
        puts “Çözüm var”
        else
        puts “Çözüm yok”
        end
        ```</p>
      <hr />
      <p>```ruby
        def triangle?(a, b, c)
        a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        end</p>
      <p>if triangle?(3, 4, 5)
        puts “Geçerli üçgen”
        else
        puts “Geçerli üçgen değil”
        end
        ```</p>
      <hr />
      <h3 id="l-operatr">Üçlü operatörü</h3>
      <p>Ternary operatörü</p>
      <p>```ruby
        def has_solution?(a, b, c)
        (b ** 2 - 4 * a * c) &gt;= 0.0
        end</p>
      <p>puts “Çözüm #{has_solution?(1.0, 0.0, 1.0) ? ‘var’ : ‘yok’}”</p>
      <p>def triangle?(a, b, c)
        a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a
        end</p>
      <p>puts “Geçerli üçgen#{triangle?(3, 4, 5) ? ‘’ : ‘ değil’}”
        ```</p>
      <hr />
      <h3 id="kapsam">Kapsam</h3>
      <p>```ruby
        a, b, c = 1.0, 0.0, 1.0</p>
      <p>def calculate_roots(a, b, c)
        delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <pre><code>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a
  
puts "Kökler: (#{p}, #{q})"   else
puts 'Çözüm yok'   end end
</code></pre>
      <p>calculate_roots(a, b, c)</p>
      <p>puts delta #=&gt; ?
        ```</p>
      <hr />
      <p>Metotlar dışarıya kapalı bir kutu gibi davranır</p>
      <ul>
        <li>
          <p>Metot gövdesi bir kapsam (“scope”) belirler: yerel kapsam (“local scope”)</p>
        </li>
        <li>
          <p>Yerel kapsamdaki bir değişken dışarı sızmaz (ör. <code>delta</code>)</p>
        </li>
        <li>
          <p>Benzer şekilde metot dışındaki hiç bir değer argümanlar yoluyla verilmedikçe içeri sızmaz</p>
        </li>
        <li>
          <p>Metodun dış dünyayla yegane kontak noktaları: giriş argümanları ve dönüş değeri</p>
        </li>
      </ul>
      <hr />
      <h3 id="simlendirilmi-argmanlar">İsimlendirilmiş argümanlar</h3>
      <p>```ruby
        def calculate_roots(a:, b:, c:)
        delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <pre><code>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a
  
puts "Kökler: (#{p}, #{q})"   else
puts 'Çözüm yok'   end end
</code></pre>
      <p>calculate_roots(a: 1.0, b: 0.0, c: 1.0)
        ```</p>
      <hr />
      <ul>
        <li>
          <p>Veriliş sırasıyla anlamlandırılan argümanlar: “pozisyonel argümanlar”</p>
        </li>
        <li>
          <p>Argümanları veriliş sırasıyla değil de isimleriyle belirtsek?</p>
        </li>
        <li>
          <p>Özellikle birden fazla sayıda argüman geçirmemiz gerektiğinde yararlı</p>
        </li>
        <li>
          <p>Neyin ne olduğunu çağırma zamanında karıştırmamış oluyoruz</p>
        </li>
      </ul>
      <hr />
      <h3 id="ntanml-argmanlar">Öntanımlı argümanlar</h3>
      <p>```ruby
        def calculate_roots(a: 0.0, b: 0.0, c: 0.0)
        delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <pre><code>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a
  
puts "Kökler: (#{p}, #{q})"   else
puts 'Çözüm yok'   end end
</code></pre>
      <p>calculate_roots(a: 1.0, c: 1.0)</p>
      <p>calculate_roots
        ```</p>
      <hr />
      <p>Öntanımlı argümanlar “pozisyonel argümanlar” için de geçerli</p>
      <p>```ruby
        def calculate_roots(a = 0.0, b = 0.0, c = 0.0)
        delta = b ** 2 - 4 * a * c</p>
      <p>if delta &gt;= 0.0
        delta_sqrt = Math.sqrt(delta)</p>
      <pre><code>p, q = (-b - delta_sqrt) / 2 * a, (-b + delta_sqrt) / 2 * a
  
puts "Kökler: (#{p}, #{q})"   else
puts 'Çözüm yok'   end end
</code></pre>
      <p>calculate_roots</p>
      <p>calculate_roots(1.0, 0.0, 1.0)
        ```</p>
      <ul>
        <li>
          <p>İlk çağrıda işe yaradı</p>
        </li>
        <li>
          <p>Fakat ikincide işe yaramıyor</p>
        </li>
        <li>
          <p>Zorunlu olarak tüm argümanları girmek zorunda kaldık, neden?</p>
        </li>
      </ul>
      <hr />
      <p>İkinci derece denklem örneğinde bir sorun daha var</p>
      <ul>
        <li>
          <p>“Bir metot tek bir iş yapmalı” kuralı ihlal edilmiş</p>
        </li>
        <li>
          <p>Bunu düzeltmek şu aşamada zor</p>
        </li>
        <li>
          <p>Ruby’de metotlar sadece tek bir değer dönebilir</p>
        </li>
        <li>
          <p>Birden fazla değeri tek bir değer halinde dönmek gerekiyor</p>
        </li>
        <li>
          <p>Bunun yolu?  Diziler</p>
        </li>
      </ul>
      <hr />
      <h3 id="dng">Döngü</h3>
      <p>Bilgisayarın en temel kabiliyeti: bir işlemi tekrar tekrar yapabilmek</p>
      <hr />
      <p>Örnek: Kullanıcıdan geçerli bir tamsayı al</p>
      <p><code>ruby
          01  def getnum
          02    print 'Lütfen bir sayı girin [ENTER sonlandırır]: '
          03  
          04    while !(string = gets.chomp).empty?
          05      number = Integer(string, exception: false)
          06      if number
          07        return number
          08      end
          09  
          10      print "Geçersiz sayı: '#{string}'.  Lütfen tekrar girin: "
          11    end
          12  
          13    nil
          14  end
        </code></p>
      <hr />
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>while</code></p>
        </li>
        <li>
          <p>Çoğu durumda “… oldukça/olmadıkça” veya “… olduğu sürece/olmadığı sürece” gibi okuyabilirsiniz</p>
        </li>
      </ul>
      <hr />
      <p>Sözde kod</p>
      <p>```
        Girdi al, bu boş bir dizgi olmadığı sürece
        dizgiyi tamsayıya çevir
        eğer dönüşüm geçerli ise tamsayıyı dön</p>
      <p>hata görüntüle
        ```</p>
      <hr />
      <p>```ruby
        def getnum
        print ‘Lütfen bir sayı girin [ENTER sonlandırır]: ‘</p>
      <p>until (string = gets.chomp).empty?
        number = Integer(string, exception: false)
        return number if number</p>
      <pre><code>print "Geçersiz sayı: '#{string}'.  Lütfen tekrar girin: "   end
</code></pre>
      <p>nil
        end
        ```</p>
      <hr />
      <ul>
        <li>
          <p>Yeni anahtar kelime: <code>until</code></p>
        </li>
        <li>
          <p><code>if</code>/<code>unless</code> ilişkisine benzer şekilde <code>while</code>/<code>until</code></p>
        </li>
        <li>
          <p>Olumsuz lojik için kullanılıyor</p>
        </li>
        <li>
          <p>Basit ifadeler kullanıldığı sürece okunurluğu bir parça arttırıyor</p>
        </li>
      </ul>
      <hr />
      <h3 id="rnek-say-tahmini">Örnek: Sayı tahmini</h3>
      <p>Verilen bir aralık içinde belirlenmiş bir tamsayıyı tahmin et</p>
      <hr />
      <p>İyileştirmeler</p>
      <ul>
        <li>Kod tekrarını nasıl önleriz?</li>
        <li>Döngü üzerinde tam denetim nasıl kurarız?</li>
        <li>Kullanıcıya ipucu verebilir miyiz?  “Büyük/küçük” gibi</li>
        <li>Maksimum deneme sayısını sınırlayabilir miyiz?</li>
        <li>Sayı aralığını değişken yapabilir miyiz?</li>
        <li>UX: Her tahminde deneme sayısını da kullanıcıya bildirebilir miyiz?</li>
        <li>Sayı aralığı ve maksimum deneme sayısını program çalıştırılırken girebilir miyiz?</li>
      </ul>
      <hr />
      <h3 id="yeni">Yeni</h3>
      <ul>
        <li>Yeni anahtar kelime: <code>loop</code>: açık uçlu döngüler kurmaya yarıyor</li>
        <li>Yeni anahtar kelime: <code>break</code>: döngü sonlandırmaya yarıyor</li>
      </ul>
      <hr />
      <ul>
        <li>
          <p><code>break</code> anahtar kelimesi <code>while</code>, <code>until</code> ve gelecekte göreceğiniz tüm döngülerde, döngüyü kırmak için kullanılır</p>
        </li>
        <li>
          <p><code>loop</code>‘a özgü değil</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Sabitler: büyük harf ile başlayan (ve çoğunlukla hepsi büyük harften oluşan) tanımlayıcılar</p>
        </li>
        <li>
          <p><code>ARGV</code>: komut satırı argümanlarını tutan (sabit isimli bir) dizi</p>
        </li>
        <li>
          <p><code>||=</code> öntanımlı değer atama özdeyişi</p>
        </li>
        <li>
          <p><code>STDIN</code>: standart girdiya karşı düşen sabit</p>
        </li>
        <li>
          <p><code>STDIN.gets</code>: daima standart girdiden (ör. klavye) okuma yapan özdeyiş</p>
        </li>
      </ul>
      <hr />
      <h3 id="diziler">Diziler</h3>
      <p>Birbiriyle ilişkili (bir küme oluşturan) değerleri barındıran veri türü</p>
      <p><code>ruby
          days = ['pazartesi', 'salı', 'çarşamba', 'perşembe', 'cuma', 'cumartesi', 'pazar']
        </code></p>
      <ul>
        <li>
          <p>Kümedeki her değere tek bir tanımlayıcı üzerinden erişiyoruz, nasıl?</p>
        </li>
        <li>
          <p>İndis kullanarak, ilk değerin indisi <code>0</code>, her seferinde 1 artıyor</p>
        </li>
      </ul>
      <p><code>ruby
          days[0]   #=&gt; 'pazartesi'
          days[1]   #=&gt; 'salı'
          days[6]   #=&gt; 'pazar'
          days[7]   #=&gt; nil
          days[100] #=&gt; nil
        </code></p>
      <hr />
      <p>Pek çok programlama dilinde saymaya <code>0</code>‘dan başlanır, <strong><code>1</code>‘den değil</strong></p>
      <ul>
        <li>Bu durumda son elemanın indisi ne oluyor?  <code>&lt;dizi uzunluğu&gt; - 1</code></li>
      </ul>
      <hr />
      <h3 id="sz-dizimi">Söz dizimi</h3>
      <ul>
        <li>
          <p>Birden fazla satıra yayabiliriz</p>
          <p><code>ruby
              days = [
              'pazartesi',
              'salı',
              'çarşamba',
              'perşembe',
              'cuma',
              'cumartesi',
              'pazar',
              ]
            </code></p>
        </li>
        <li>
          <p>Son elemandan sonra da <code>,</code> kullanmaya izin var (ama topluluk stilinde hoş bakılmıyor)</p>
        </li>
        <li>
          <p>Özel olarak dizgilerden oluşan dizileri ilklendirmek için <code>%w[]</code> kullanabiliriz</p>
          <p><code>ruby
              days = %w[pazartesi salı çarşamba perşembe cuma cumartesi pazar]
            </code></p>
        </li>
      </ul>
      <hr />
      <h3 id="deer-atama">Değer atama</h3>
      <p>Basitçe ilgili indisteki elemana değer atamamız yeterli</p>
      <p><code>ruby
          days[0] = 'monday'
        </code></p>
      <hr />
      <h3 id="temel-metotlar">Temel metotlar</h3>
      <ul>
        <li>
          <p>Dizi uzunluğu: <code>days.size</code> veya <code>days.length</code> (eşdeğer)</p>
        </li>
        <li>
          <p>İlk eleman: <code>days.first</code></p>
        </li>
        <li>
          <p>Son eleman: <code>days.last</code></p>
        </li>
      </ul>
      <hr />
      <h3 id="negatif-indisler">Negatif indisler</h3>
      <p>Diziye sondan erişmek için kullanılıyor</p>
      <p><code>ruby
          days[-1]         #=&gt; 'pazar'
          days[-2]         #=&gt; 'cumartesi'
          days[-7]         #=&gt; 'pazartesi'
          days[-days.size] #=&gt; 'pazartesi'
          days[-8]         #=&gt; nil
          days[-100]       #=&gt; nil
        </code></p>
      <hr />
      <h3 id="dizi-sonuna-yeni-eleman-eklemek">Dizi sonuna yeni eleman eklemek</h3>
      <p>Çok sık yaptığımız bir işlem</p>
      <p><code>ruby
          a = []
          a &lt;&lt; 3
          a &lt;&lt; 5
          a &lt;&lt; 9
          a #=&gt; [3, 5, 9]
        </code></p>
      <p>Dizinin başına (veya seçilen bir indisten önce/sonraya) elema eklemek?  Düşündüğünüz kadar sık ihtiyaç duyulacak bir
        işlem değil</p>
      <p><code>ruby
          a = []
          a.unshift 3
          a.unshift 5
          a.unshift 9
          a #=&gt; [9, 5, 3]
        </code></p>
      <hr />
      <h3 id="dizide-dolamak">Dizide dolaşmak</h3>
      <p>En sık yapılan işlem, bir tür döngü</p>
      <ul>
        <li>
          <p>Şu ana kadar öğrendiğiniz döngü deyimleriyle yapılabilir</p>
        </li>
        <li>
          <p>Ama bunu yapmayın, Ruby’de dizilerde dolaşmak için çok daha güçlü yöntemler var</p>
        </li>
      </ul>
      <hr />
      <h3 id="each"><code>each</code></h3>
      <p>Ruby’de <code>Enumerable</code> modülünde tanımlı olan ve dizi türündeki tüm nesnelerin cevap verdiği bir metot</p>
      <p><code>ruby
          days.each do |day|
          puts day
          end
        </code></p>
      <hr />
      <p><strong>Ruby’de dizilerde dolaşmak için daima <code>each</code> ve daha sonra gösterilecek <code>Enumerable</code> metotlarını kullanın</strong></p>
      <ul>
        <li>
          <p><code>while</code>, <code>until</code>, <code>loop</code> (ve anlatmaya gerek görmediğimiz <code>for</code>) gibi döngü deyimlerini <strong>kullanmayın</strong></p>
        </li>
        <li>
          <p>Bu deyimlere çoğunlukla dizi içermeyen düzensiz döngülerde ihtiyaç duyacaksınız</p>
        </li>
        <li>
          <p>Bu uyarı özellikle diğer programlama dillerinden bilgi transfer edeceklere önemli</p>
        </li>
      </ul>
      <hr />
      <h3 id="eachwithindex"><code>each_with_index</code></h3>
      <p>Dolaşırken indis bilgisine ihtiyacımız varsa?</p>
      <p><code>ruby
          days.each_with_index do |day, i|
          puts "#{i}: #{day}"
          end
        </code></p>
      <hr />
      <h3 id="bloklar">Bloklar</h3>
      <p>Metotlara geçirilen eylemler</p>
      <ul>
        <li>
          <p>Daha teknik bir anlatımla isimsiz (anonim) işlevler</p>
        </li>
        <li>
          <p>Ruby’nin çok önemli bir özelliği</p>
        </li>
      </ul>
      <hr />
      <p>Blokları anlayabilmemiz için hikayede biraz geriye gitmek zorundayız</p>
      <ul>
        <li>
          <p>Ruby’de hemen her şey akıllı bir “nesne”</p>
        </li>
        <li>
          <p>Uygun metotlarla uyararak nesnelerin istediğiniz davranışı göstermesini sağlayabilirsiniz</p>
        </li>
        <li>
          <p>Örneğin dizgiler birer nesne</p>
          <p><code>ruby
              irb(main):001:0&gt; 'This is a test'.length
              =&gt; 14
              irb(main):002:0&gt; 'This is a test'.upcase
              =&gt; THIS IS A TEST
            </code></p>
        </li>
        <li>
          <p><strong>Sayılar da öyle</strong></p>
          <p><code>ruby
              irb(main):003:0&gt; 3.times { puts 'Test' }
              Test
              Test
              Test
              =&gt; 3
            </code></p>
        </li>
      </ul>
      <hr />
      <p>Son örneğe yoğunlaşalım</p>
      <p><code>ruby
          3.times { puts 'Test' }
        </code></p>
      <ul>
        <li>
          <p><code>3</code> bir tamsayı nesnesi, <code>times</code> bu nesnenin bir metotu</p>
        </li>
        <li>
          <p>Öyle ki bu metota hangi eylemi tekrarlayacağını bildirebiliyorsunuz</p>
        </li>
        <li>
          <p>Nasıl?  Eylemi gerçekleyen bir kod bloğuyla</p>
          <p><code>ruby
              { puts 'Test' }
            </code></p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Kod bloklarını <code>{...}</code> yerine <code>do ... end</code> ile de yazabiliriz</p>
          <p><code>ruby
              3.times do
              puts 'Test'
              end
            </code></p>
        </li>
        <li>
          <p>Stil olarak tek satırlık bloklarda kıvrık parantezler, birden fazla satıra yayılan kod blokları için <code>do ... end</code>
            tercih ediyoruz</p>
        </li>
      </ul>
      <hr />
      <p>Metafor</p>
      <ul>
        <li>
          <p>İngiltere kraliçesi Türkiye’ye resmi ziyaret yapacak; Kraliçenin ülkede bulunduğu sürece yemekleri nasıl olacak?</p>
        </li>
        <li>
          <p>1: İngiliz protokolü Dışişleri protokolüne kraliçenin ülkedeyken yiyeceği yemeklerin listesini veya tarifini iletebilir</p>
        </li>
        <li>
          <p>2: Kraliçe yemekleri yapacak özel ahçısını bizzat yanında getirebilir</p>
        </li>
        <li>
          <p>İlki klasik yöntem, bir metota (ör. <code>yemek_hazırla</code>) veri girilmesi (yemek listesi veya tarifler)</p>
        </li>
        <li>
          <p>İkincisinde ise metota bir eylem veriliyor, ahçının eylemleri</p>
        </li>
      </ul>
      <hr />
      <p>Bir işleve eylemde ihtiyaç duyacağı bilgileri argümanlar üzerinden geçirebiliriz.</p>
      <p><code>ruby
          puts 'Test'
        </code></p>
      <ul>
        <li>
          <p><code>puts</code>: Neyi görüntüleyeyim?</p>
        </li>
        <li>
          <p>Çağıran: “Test” dizgisini</p>
        </li>
      </ul>
      <hr />
      <p>Aynı diyaloğu <code>times</code> için kurgulayalım.</p>
      <ul>
        <li><code>times</code>: <strong>kaç</strong> defa <strong>ne</strong> yapacağım?</li>
      </ul>
      <p>Ama bu soru hatalı.</p>
      <ul>
        <li>
          <p><code>times</code> metodu uyarılırken <strong>kaç</strong> defa bilgisini zaten alıyor, nasıl?</p>
          <p><code>ruby
              3.times ...
            </code></p>
        </li>
        <li>
          <p>Diyalog <code>times</code> ile değil <code>3</code> tamsayı nesnesi arasında gerçekleşmeli</p>
        </li>
      </ul>
      <hr />
      <p>Diyalog:</p>
      <ul>
        <li>
          <p><code>3</code>: Ne istiyorsun?</p>
        </li>
        <li>
          <p>Çağıran: Sen <strong>defa</strong> (yani <code>3</code> defa) bir şey yapmanı.</p>
        </li>
        <li>
          <p><code>3</code>: Tamam, ben <strong>defa</strong> ne yapacağım?</p>
        </li>
        <li>
          <p>Çağıran: <code>puts 'Test'</code> (‘Test’ dizgisini görüntüle).</p>
        </li>
      </ul>
      <hr />
      <p>Sonuçlar:</p>
      <ul>
        <li>
          <p>Nesnelere sadece veri değil eylem de bildirilebiliyor</p>
        </li>
        <li>
          <p>Bu sayede çeşitlenebilir davranışlar elde edebiliyoruz</p>
        </li>
        <li>
          <p>Tekrarlama eylemiyle (<code>times</code>), tekrarlanacak eylemi (<code>puts "Test"</code>) ayırıyoruz</p>
        </li>
        <li>
          <p><code>times</code> bir metot, <code>puts 'Test'</code> ise bu metota geçirilen bir blok</p>
        </li>
      </ul>
      <hr />
      <p>Bloklar metotumsu (veya fonksiyonumsu) şeyler</p>
      <ul>
        <li>
          <p>Blok argümanları (varsa) <code>|...|</code> karakterleri arasında (metotlardaki parantezler)</p>
        </li>
        <li>
          <p>Blok dönüş değeri metotlardaki gibi etkin olan son satır</p>
        </li>
        <li>
          <p>Dikkat! Bloğun dönüş değerini bloğu alan metotun dönüş değeriyle karıştırmayın</p>
        </li>
        <li>
          <p>Nihai “dönüş değeri”ni bloğun verildiği metot belirliyor</p>
          <p><code>ruby
              3.times { 'Merhaba' } #=&gt; 3 döner
            </code></p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>Bloklarda da erken çıkış için (<code>return</code> yerine) <code>break</code> veya <code>next</code> tercih ediyoruz</li>
      </ul>
      <hr />
      <p>```ruby
        %w[samsun istanbul izmir adana].each do |city|
        next if city.include? ‘a’</p>
      <p>puts city
        end
        ```</p>
      <p>```ruby
        %w[samsun istanbul izmir adana].each do |city|
        break unless city.include? ‘a’</p>
      <p>puts city
        end
        ```</p>
      <hr />
      <h3 id="blok-kapsam">Blok kapsamı</h3>
      <p>“Bloklar metotumsu (veya fonksiyonumsu) şeyler” demiştik</p>
      <ul>
        <li>
          <p>Blok içinde tanımlanan bir değişken bloğa özgüdür, blok dışına çıkamaz</p>
          <p>```ruby
            %w[samsun istanbul izmir adana].each do |city|
            next if city.include? ‘a’</p>
          <p>puts city
            end</p>
          <p>puts city
            ```</p>
        </li>
        <li>
          <p>Bu kod neden hata veriyor?</p>
        </li>
        <li>
          <p>Düzeltmek için ne yapılabilir?</p>
        </li>
      </ul>
      <hr />
      <ul>
        <li>
          <p>Bazen bir blokta üretilen bir değeri dış kapsama taşımak isteyebiliriz</p>
          <p>```ruby
            cities_with_a = []</p>
          <p>%w[samsun istanbul izmir adana].each do |city|
            cities_with_a « city if city.include? ‘a’
            end</p>
          <p>puts cities_with_a
            ```</p>
        </li>
        <li>
          <p>Sonuç: dış kapsama taşınacak değeri tutacak değişkeni bloktan önce tanımlayın (<code>nil</code> gibi bir değerle de olsa)</p>
        </li>
        <li>
          <p>Fakat bunu yapmanın hemen hemen daima daha iyi bir yolu vardır (örnek için <code>select</code> veya <code>collect</code>)</p>
        </li>
      </ul>
    </div>
    <script>
      feather.replace()
    </script>
  </body>
</html>